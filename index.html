<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>顶流广告技术有限公司</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-group {
            margin-bottom: 20px;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        .results {
            margin-top: 20px;
        }
        .city-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .city-item:last-child {
            border-bottom: none;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .error {
            color: red;
            margin: 10px 0;
        }
        .progress-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-filled {
            height: 20px;
            background-color: #4CAF50;
            text-align: center;
            line-height: 20px;
            color: white;
            transition: width 0.3s;
        }
        .status-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .status-item {
            margin-bottom: 5px;
            font-size: 14px;
        }
        .status-pending {
            color: #888;
        }
        .status-processing {
            color: #ff9800;
        }
        .status-success {
            color: #4CAF50;
        }
        .status-error {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>顶流广告技术有限公司</h1>
        <div class="input-group">
            <input type="text" id="addressInput" placeholder="请输入店铺地址">
            <button onclick="calculateDistances()">点击查询</button>
            <a href="stats.html" style="display: inline-block; margin-left: 10px; text-decoration: none;">
                <button type="button" style="background-color: #2196F3;">查看API使用统计</button>
            </a>
        </div>
        <div class="note" style="margin-top: 10px; font-size: 14px; color: #666;">
            Ski定点查询
        </div>
        <div id="loading" class="loading">正在计算中...</div>
        <div id="error" class="error"></div>
        <div id="progress-container" class="progress-container" style="display: none;">
            <div class="progress-bar">
                <div id="progress-filled" class="progress-filled" style="width: 0%">0%</div>
            </div>
            <div id="status-list" class="status-list"></div>
        </div>
        <div id="results" class="results"></div>
    </div>

    <script src="github-api-storage.js"></script>
    <script>
        // 警告：这里直接暴露了 API 密钥，在生产环境中应该使用后端服务来保护密钥
        const LOCATIONIQ_KEYS = [
            'pk.7a610aa57d0d98f9e069f4060b882135',
            'pk.8d623bbfe7c58d6fe46c73ff34aad01f',
            'pk.ee34ef023b0a61d9bcb6205c6372e4a7',
            'pk.b0de4a0841c2547ad5724f78f3acdcbc',
            'pk.7d611d26ef05fc49cffe2da526053667',
            'pk.da33d9653e55e08fbcfe2da526053667',
            'pk.9dc953462b77df2460c7f05732706958',
            'pk.45f647b1a1780e83133ecacaaf1cd153',
            'pk.bffb77dd0872aa9d9109a5c15095cef6'
        ];
        
        let currentKeyIndex = 0;
        
        // 获取下一个API密钥，按顺序轮询
        function getNextApiKey() {
            const key = LOCATIONIQ_KEYS[currentKeyIndex];
            currentKeyIndex = (currentKeyIndex + 1) % LOCATIONIQ_KEYS.length;
            return key;
        }

        let citiesData = null;
        let dataLoaded = false;
        let isLoading = false;
        const MAX_CONCURRENT_REQUESTS = LOCATIONIQ_KEYS.length; // 最大并发请求数 = API密钥数量

        // 州缩写到全名的映射
        const stateAbbreviations = {
            "AL": "alabama",
            "AK": "alaska",
            "AZ": "arizona",
            "AR": "arkansas",
            "CA": "california",
            "CO": "colorado",
            "CT": "connecticut",
            "DE": "delaware",
            "FL": "florida",
            "GA": "georgia",
            "HI": "hawaii",
            "ID": "idaho",
            "IL": "illinois",
            "IN": "indiana",
            "IA": "iowa",
            "KS": "kansas",
            "KY": "kentucky",
            "LA": "louisiana",
            "ME": "maine",
            "MD": "maryland",
            "MA": "massachusetts",
            "MI": "michigan",
            "MN": "minnesota",
            "MS": "mississippi",
            "MO": "missouri",
            "MT": "montana",
            "NE": "nebraska",
            "NV": "nevada",
            "NH": "newhampshire",
            "NJ": "newjersey",
            "NM": "newmexico",
            "NY": "newyork",
            "NC": "northcarolina",
            "ND": "northdakota",
            "OH": "ohio",
            "OK": "oklahoma",
            "OR": "oregon",
            "PA": "pennsylvania",
            "RI": "rhodeisland",
            "SC": "southcarolina",
            "SD": "southdakota",
            "TN": "tennessee",
            "TX": "texas",
            "UT": "utah",
            "VT": "vermont",
            "VA": "virginia",
            "WA": "washington",
            "WV": "westvirginia",
            "WI": "wisconsin",
            "WY": "wyoming",
            "DC": "district of columbia"
        };

        // 全局API使用数据对象
        let apiUsageData = null;

        // 页面加载时初始化数据
        window.onload = function() {
            // 检查是否有GitHub令牌
            if (GitHubApiStorage.hasValidToken()) {
                console.log('GitHub令牌已设置，将使用GitHub API存储数据');
            } else {
                console.warn('未找到有效的GitHub令牌，无法使用GitHub API存储数据');
            }
            
            // 加载城市数据
            loadCitiesData();
        };
        
        // 立即加载城市数据
        loadCitiesData();

        // 加载城市数据的函数
        async function loadCitiesData() {
            if (isLoading) return; // 避免重复加载
            
            isLoading = true;
            document.getElementById('error').textContent = '正在加载城市数据...';
            
            try {
                console.log('开始加载城市数据...');
                const response = await fetch('skipCities.json');
                if (!response.ok) {
                    throw new Error(`加载城市数据失败: ${response.status} ${response.statusText}`);
                }
                const text = await response.text();
                try {
                    const data = JSON.parse(text);
                    if (!data || typeof data !== 'object') {
                        throw new Error('城市数据格式错误');
                    }
                    citiesData = data;
                    dataLoaded = true;
                    console.log('城市数据加载成功:', Object.keys(citiesData).length, '个州');
                    console.log('加载的州列表:', Object.keys(citiesData));
                    document.getElementById('error').textContent = '';
                } catch (jsonError) {
                    console.error('JSON解析错误:', jsonError);
                    console.log('接收到的内容:', text);
                    throw new Error(`城市数据JSON解析失败: ${jsonError.message}`);
                }
            } catch (error) {
                console.error('加载城市数据错误:', error);
                document.getElementById('error').textContent = `无法加载城市数据: ${error.message}，请刷新页面重试`;
            } finally {
                isLoading = false;
            }
        }

        // 辅助函数：延迟指定时间
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 带重试的API请求，支持多密钥轮询
        async function fetchWithRetry(url, retries = 3, delayMs = 1000) {
            let lastError = null;
            let triedKeys = new Set();
            
            // 获取原始URL不包含API密钥的部分
            const baseUrl = url.replace(/key=[^&]+/, 'key=API_KEY_PLACEHOLDER');
            
            // 尝试每个API密钥，直到成功或全部尝试完
            while (triedKeys.size < LOCATIONIQ_KEYS.length) {
                const currentKey = getNextApiKey();
                
                // 如果已经尝试过这个密钥，跳过
                if (triedKeys.has(currentKey)) {
                    // 如果所有密钥都已尝试过，退出循环
                    if (triedKeys.size >= LOCATIONIQ_KEYS.length) {
                        break;
                    }
                    continue;
                }
                
                triedKeys.add(currentKey);
                
                // 替换URL中的API密钥
                const requestUrl = baseUrl.replace('API_KEY_PLACEHOLDER', currentKey);
                console.log(`使用API密钥: ${currentKey.substring(0, 5)}...${currentKey.substring(currentKey.length - 4)}`);
                
                for (let i = 0; i < retries; i++) {
                    try {
                        // 如果不是第一次尝试，先等待
                        if (i > 0) {
                            console.log(`尝试重新请求 (${i+1}/${retries}), 等待 ${delayMs}ms...`);
                            await delay(delayMs);
                            // 每次重试增加等待时间
                            delayMs = delayMs * 1.5;
                        }
                        
                        const response = await fetch(requestUrl);
                        if (response.ok) {
                            // 记录成功的API请求到统计系统
                            try {
                                // 使用GitHub API存储记录API请求
                                GitHubApiStorage.recordApiRequest(currentKey);
                            } catch (e) {
                                console.error("记录API使用失败:", e);
                            }
                            return response;
                        } else if (response.status === 429) {
                            console.warn(`API密钥 ${currentKey.substring(0, 5)}... 请求速率限制，将尝试下一个密钥...`);
                            // 如果是速率限制错误，立即尝试下一个API密钥
                            break;
                        } else {
                            // 其他错误，获取错误信息
                            const errorText = await response.text();
                            lastError = new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                            // 如果不是速率限制错误，继续重试当前密钥
                            if (i === retries - 1) {
                                // 当前密钥的最后一次尝试失败，尝试下一个密钥
                                break;
                            }
                        }
                    } catch (error) {
                        lastError = error;
                        if (i === retries - 1) {
                            // 当前密钥的最后一次尝试失败，尝试下一个密钥
                            break;
                        }
                    }
                }
            }
            
            // 所有密钥都尝试过了，抛出最后一个错误
            throw lastError || new Error('所有API密钥请求都失败了');
        }

        // 使用 LocationIQ API 获取地理编码
        async function geocodeAddress(address) {
            try {
                // 清理和标准化美国地址格式
                const cleanedAddress = address
                    .replace(/\./g, ',')  // 将点号替换为逗号
                    .replace(/\s+/g, ' ')  // 将多个空格替换为单个空格
                    .replace(/(\d+)([A-Za-z])/g, '$1 $2')  // 在数字和字母之间添加空格
                    .replace(/([A-Za-z])(\d+)/g, '$1 $2')  // 在字母和数字之间添加空格
                    .trim();

                console.log('清理后的地址:', cleanedAddress);

                // 先尝试从地址中提取州缩写
                let state = null;
                
                // 尝试匹配地址中的州缩写
                // 这会匹配地址中类似 "XX 12345" 或 "XX," 的模式，其中 XX 是两个大写字母
                const stateZipMatch = cleanedAddress.match(/\b([A-Z]{2})[\s,]+\d{5}\b/);
                const stateMatch = cleanedAddress.match(/\b([A-Z]{2})[\s,]*$/);
                
                if (stateZipMatch) {
                    state = stateZipMatch[1];
                    console.log('从地址中提取到州缩写(带邮编):', state);
                } else if (stateMatch) {
                    state = stateMatch[1];
                    console.log('从地址中提取到州缩写:', state);
                }
                
                // 验证提取的州缩写是否有效
                if (state && stateAbbreviations[state]) {
                    console.log('验证通过，有效的州缩写:', state);
                } else {
                    // 如果没有提取到有效州缩写，尝试搜索地址中的州名
                    for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
                        // 创建一个正则表达式，匹配州全名
                        const stateRegex = new RegExp(`\\b${fullName.replace(/\s+/g, '\\s+')}\\b`, 'i');
                        if (stateRegex.test(cleanedAddress.toLowerCase())) {
                            state = abbr;
                            console.log('从地址中找到州全名，转换为缩写:', state);
                            break;
                        }
                    }
                    
                    if (!state) {
                        console.log('无法从地址直接提取州信息，继续使用API...');
                    }
                }

                const url = `https://us1.locationiq.com/v1/search.php?key=API_KEY_PLACEHOLDER&q=${encodeURIComponent(cleanedAddress)}&format=json&countrycodes=us&addressdetails=1`;
                console.log('准备请求地理编码API，请求URL:', url.replace(/key=[^&]+/, 'key=***'));
                
                const response = await fetchWithRetry(url, 3, 1500);
                const data = await response.json();
                console.log('地理编码API响应:', data);
                
                if (!Array.isArray(data) || data.length === 0) {
                    throw new Error('未找到匹配的地址');
                }

                const firstResult = data[0];
                if (!firstResult || !firstResult.lat || !firstResult.lon) {
                    throw new Error('API返回的数据缺少坐标信息');
                }

                // 如果我们尚未从地址中提取到州信息，尝试从API响应中获取
                if (!state && firstResult.address) {
                    // 首先检查 state_code（州缩写）
                    if (firstResult.address.state_code) {
                        state = firstResult.address.state_code.toUpperCase();
                        console.log('从API获取到州缩写:', state);
                    } 
                    // 如果没有州缩写，则尝试获取州全名并转换为缩写
                    else if (firstResult.address.state) {
                        const stateName = firstResult.address.state.toLowerCase();
                        console.log('从API获取到州全名:', stateName);
                        
                        // 查找州全名对应的缩写
                        for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
                            if (fullName === stateName) {
                                state = abbr;
                                console.log('通过查找转换州全名到缩写:', state);
                                break;
                            }
                        }
                    }
                }

                // 如果仍然没有找到有效的州信息，尝试更广泛的提取方式
                if (!state || !stateAbbreviations[state]) {
                    console.log('尝试更广泛地提取州信息');
                    
                    // 尝试从地址中提取所有大写字母对
                    const allCapsMatches = cleanedAddress.match(/\b([A-Z]{2})\b/g);
                    if (allCapsMatches) {
                        for (const potentialState of allCapsMatches) {
                            if (stateAbbreviations[potentialState]) {
                                state = potentialState;
                                console.log('从地址中找到可能的州缩写:', state);
                                break;
                            }
                        }
                    }
                    
                    // 最后的尝试：检查地址中是否包含任何州的名称（不区分大小写）
                    if (!state) {
                        const lowerAddress = cleanedAddress.toLowerCase();
                        for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
                            if (lowerAddress.includes(fullName) || 
                                lowerAddress.includes(abbr.toLowerCase())) {
                                state = abbr;
                                console.log('在地址中找到州名的匹配:', state);
                                break;
                            }
                        }
                    }
                }

                // 最终验证州缩写是否有效
                if (!state) {
                    throw new Error('无法识别地址中的州信息，请确保地址中包含有效的州缩写或州名');
                }
                
                if (!stateAbbreviations[state]) {
                    throw new Error(`无效的州缩写: ${state}，当前支持的州缩写有: ${Object.keys(stateAbbreviations).join(', ')}`);
                }

                return {
                    lat: firstResult.lat,
                    lon: firstResult.lon,
                    state: state
                };
            } catch (error) {
                console.error('地理编码错误:', error);
                throw new Error(`地理编码请求失败: ${error.message}`);
            }
        }

        // 计算驾车时间
        async function calculateDrivingTime(origin, destination) {
            try {
                // 添加参数尝试提高准确性
                const url = `https://us1.locationiq.com/v1/matrix/driving/${origin.lon},${origin.lat};${destination.lon},${destination.lat}?key=API_KEY_PLACEHOLDER&annotations=distance,duration`;
                console.log('准备请求Matrix API...');
                
                const response = await fetchWithRetry(url, 3, 1500);
                const data = await response.json();
                console.log('Matrix API响应:', data);
                
                if (!data) {
                    throw new Error('API返回了空数据');
                }
                
                if (data.error) {
                    throw new Error(`API返回错误: ${data.error}`);
                }
                
                if (!data.durations || !Array.isArray(data.durations) || data.durations.length === 0) {
                    throw new Error('API响应中缺少持续时间数据');
                }
                
                if (!data.durations[0] || !Array.isArray(data.durations[0]) || data.durations[0].length < 2) {
                    throw new Error('API响应中的持续时间数据格式无效');
                }
                
                if (data.durations[0][1] === null || data.durations[0][1] === undefined) {
                    throw new Error('API返回的持续时间值无效');
                }
                
                // 驾车时间（分钟）
                const drivingTime = Math.round(data.durations[0][1] / 60);
                
                // 如果API返回了距离信息
                let distance = null;
                if (data.distances && Array.isArray(data.distances) && 
                    data.distances.length > 0 && Array.isArray(data.distances[0]) && 
                    data.distances[0].length > 1 && data.distances[0][1] !== null) {
                    // 距离（米）转换为英里 (1英里 = 1609.34米)
                    distance = (data.distances[0][1] / 1609.34).toFixed(1);
                } else {
                    console.log('API没有返回有效的距离信息，使用哈弗辛公式计算直线距离');
                    // 如果API没有返回距离，使用哈弗辛公式计算直线距离（千米）然后转换为英里
                    // 1千米 = 0.621371英里
                    const kmDistance = calculateHaversineDistance(
                        origin.lat, origin.lon, 
                        destination.lat, destination.lon
                    );
                    distance = (kmDistance * 0.621371).toFixed(1);
                }
                
                console.log(`计算结果: 驾车时间=${drivingTime}分钟, 距离=${distance}英里`);
                return {
                    duration: drivingTime,
                    distance: parseFloat(distance)
                };
            } catch (error) {
                console.error('距离计算错误:', error);
                // 尝试使用哈弗辛公式作为回退方法
                console.log('尝试使用哈弗辛公式作为回退方法计算距离');
                try {
                    const kmDistance = calculateHaversineDistance(
                        origin.lat, origin.lon, 
                        destination.lat, destination.lon
                    );
                    const distance = (kmDistance * 0.621371).toFixed(1);
                    // 使用简单的估算: 平均速度约为每小时50英里
                    const estimatedMinutes = Math.round((parseFloat(distance) / 50) * 60);
                    
                    console.log(`使用哈弗辛公式计算的结果: 预计驾车时间=${estimatedMinutes}分钟, 距离=${distance}英里 (注: 时间为估计值)`);
                    return {
                        duration: estimatedMinutes,
                        distance: parseFloat(distance),
                        estimated: true  // 标记这是估计值
                    };
                } catch (fallbackError) {
                    console.error('哈弗辛公式计算也失败:', fallbackError);
                    throw new Error(`距离计算请求失败: ${error.message}`);
                }
            }
        }

        // 使用哈弗辛公式计算两点之间的直线距离（单位：千米）
        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // 地球半径（千米）
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // 创建一个高效的请求队列，支持动态调整并发数
        class RequestQueue {
            constructor(maxConcurrent = 5, initialDelay = 100) {
                this.maxConcurrent = maxConcurrent;  // 最大并发数
                this.queue = [];                     // 请求队列
                this.active = 0;                     // 当前活动请求数
                this.results = [];                   // 结果集
                this.baseDelay = initialDelay;       // 基础延迟时间(ms)
                this.currentDelay = initialDelay;    // 当前延迟时间(ms)
                this.successCount = 0;               // 连续成功请求数
                this.failureCount = 0;               // 连续失败请求数
                this.totalSuccess = 0;               // 总成功请求数
                this.totalFailure = 0;               // 总失败请求数
                this.adaptiveMode = true;            // 是否启用自适应模式
            }

            // 添加任务到队列
            add(task) {
                return new Promise((resolve, reject) => {
                    this.queue.push({
                        task,
                        resolve,
                        reject
                    });
                    this.run();
                });
            }

            // 执行队列中的任务
            async run() {
                if (this.active >= this.maxConcurrent || this.queue.length === 0) {
                    return;
                }

                // 从队列中取出一个任务
                const { task, resolve, reject } = this.queue.shift();
                this.active++;

                // 添加延迟以防止请求过快
                if (this.active > 1 && this.currentDelay > 0) {
                    await new Promise(r => setTimeout(r, this.currentDelay));
                }

                try {
                    // 执行任务
                    const result = await task();
                    this.successCount++;
                    this.failureCount = 0;
                    this.totalSuccess++;
                    resolve(result);
                    this.adjustThrottling(true);
                } catch (error) {
                    this.failureCount++;
                    this.successCount = 0;
                    this.totalFailure++;
                    reject(error);
                    this.adjustThrottling(false);
                } finally {
                    this.active--;
                    this.run(); // 继续处理队列中的下一个任务
                }
            }

            // 动态调整请求节流
            adjustThrottling(success) {
                if (!this.adaptiveMode) return;

                // 成功情况下的调整
                if (success) {
                    // 连续多次成功，可以加快速度
                    if (this.successCount >= 5) {
                        this.currentDelay = Math.max(0, this.currentDelay - 10);
                        // 如果连续成功多次，可以增加并发数，但不超过API密钥数量
                        if (this.successCount >= 10 && this.maxConcurrent < LOCATIONIQ_KEYS.length) {
                            this.maxConcurrent = Math.min(LOCATIONIQ_KEYS.length, this.maxConcurrent + 1);
                            console.log(`提高并发数到 ${this.maxConcurrent}`);
                        }
                    }
                } 
                // 失败情况下的调整
                else {
                    // 出现失败，立即减慢速度
                    this.currentDelay = this.currentDelay * 1.5 + 50;
                    
                    // 如果连续失败，减少并发数
                    if (this.failureCount >= 2) {
                        this.maxConcurrent = Math.max(1, this.maxConcurrent - 1);
                        console.log(`降低并发数到 ${this.maxConcurrent}`);
                    }
                    
                    // 如果失败率过高，增加更多延迟
                    const failureRate = this.totalFailure / (this.totalSuccess + this.totalFailure + 1);
                    if (failureRate > 0.1) {
                        this.currentDelay += 200;
                        console.log(`失败率高 (${(failureRate*100).toFixed(1)}%)，增加延迟到 ${this.currentDelay}ms`);
                    }
                }

                // 限制最小和最大延迟
                this.currentDelay = Math.min(3000, Math.max(0, this.currentDelay));
            }

            // 重置队列
            reset() {
                this.queue = [];
                this.active = 0;
                this.results = [];
                this.currentDelay = this.baseDelay;
                this.successCount = 0;
                this.failureCount = 0;
            }
        }

        // 主计算函数
        async function calculateDistances() {
            const address = document.getElementById('addressInput').value.trim();
            if (!address) {
                showError('请输入店铺地址');
                return;
            }

            // 检查城市数据是否已加载
            if (!dataLoaded || !citiesData) {
                // 尝试重新加载数据
                showError('城市数据尚未加载完成，正在尝试重新加载...');
                await loadCitiesData();
                
                // 再次检查数据是否加载成功
                if (!dataLoaded || !citiesData) {
                    showError('无法加载城市数据，请刷新页面重试');
                    return;
                }
            }

            // 显示当前加载的州数据
            console.log('当前加载的城市数据状态: 已加载=', dataLoaded);
            console.log('可用的州:', Object.keys(citiesData));

            document.getElementById('error').textContent = '';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').innerHTML = '';
            
            // 重置并显示进度容器
            const progressContainer = document.getElementById('progress-container');
            const progressFilled = document.getElementById('progress-filled');
            const statusList = document.getElementById('status-list');
            progressContainer.style.display = 'block';
            progressFilled.style.width = '0%';
            progressFilled.textContent = '0%';
            statusList.innerHTML = '';

            try {
                // 获取店铺地址的坐标和州
                console.log('开始处理地址:', address);
                const storeLocation = await geocodeAddress(address);
                console.log('解析到的位置信息:', storeLocation);
                
                if (!storeLocation || !storeLocation.state) {
                    throw new Error('无法从地址中获取有效的州信息');
                }
                
                // 根据州缩写获取全名
                const stateKey = storeLocation.state;
                
                if (!stateAbbreviations[stateKey]) {
                    showError(`未知的州缩写 "${stateKey}"，当前支持的州缩写有: ${Object.keys(stateAbbreviations).join(', ')}`);
                    return;
                }
                
                const stateFullName = stateAbbreviations[stateKey].toLowerCase();
                
                console.log('州缩写:', stateKey);
                console.log('州全名:', stateFullName);
                
                console.log('检查州数据是否存在:', stateFullName);
                console.log('城市数据中的州列表:', Object.keys(citiesData));
                
                if (!citiesData[stateFullName]) {
                    showError(`未找到州 "${stateKey}" (${stateFullName}) 的城市数据，请确认所选州的数据是否存在`);
                    console.error(`未找到州 "${stateFullName}" 的数据，可用的州有:`, Object.keys(citiesData));
                    return;
                }
                
                const stateCities = citiesData[stateFullName];
                console.log(`${stateFullName} 州的城市数据:`, stateCities);
                
                if (!Array.isArray(stateCities) || stateCities.length === 0) {
                    showError(`州 "${stateKey}" (${stateFullName}) 没有城市数据`);
                    return;
                }

                console.log(`${stateFullName} 州的城市列表:`, stateCities);

                // 初始化状态列表和结果数组
                const cityStatuses = {};
                const results = [];
                let completed = 0;
                let successCount = 0;
                let errorCount = 0;
                const total = stateCities.length;

                // 为每个城市创建状态项
                stateCities.forEach(city => {
                    const statusItem = document.createElement('div');
                    statusItem.className = 'status-item status-pending';
                    statusItem.id = `status-${city.replace(/\s+/g, '-')}`;
                    statusItem.textContent = `${city}: 等待处理...`;
                    statusList.appendChild(statusItem);
                    cityStatuses[city] = statusItem;
                });

                // 更新进度条
                function updateProgress() {
                    const percent = Math.round((completed / total) * 100);
                    progressFilled.style.width = `${percent}%`;
                    progressFilled.textContent = `${percent}%`;
                }

                // 处理单个城市的函数
                async function processCity(city) {
                    try {
                        // 更新状态为处理中
                        cityStatuses[city].className = 'status-item status-processing';
                        cityStatuses[city].textContent = `${city}: 正在计算距离...`;
                        
                        // 构建完整城市地址，确保包含正确的州名
                        const cityAddress = `${city}, ${stateKey}`;
                        console.log(`处理城市: ${cityAddress}`);
                        
                        // 直接获取城市坐标
                        const cityCoords = await geocodeAddress(cityAddress);
                        
                        if (!cityCoords || !cityCoords.lat || !cityCoords.lon) {
                            throw new Error('获取城市坐标失败');
                        }
                        
                        const travelInfo = await calculateDrivingTime(storeLocation, cityCoords);
                        
                        // 检查是否是估计值
                        const isEstimated = travelInfo.estimated ? ' (估计)' : '';
                        
                        results.push({ 
                            city, 
                            duration: travelInfo.duration, 
                            distance: travelInfo.distance,
                            estimated: travelInfo.estimated || false
                        });
                        
                        successCount++;
                        
                        // 更新状态为成功
                        cityStatuses[city].className = 'status-item status-success';
                        cityStatuses[city].textContent = `${city}: ${travelInfo.duration} 分钟 (${travelInfo.distance} 英里)${isEstimated}`;
                        return { success: true, city };
                    } catch (error) {
                        console.error(`处理城市 ${city} 时出错:`, error);
                        errorCount++;
                        // 更新状态为错误
                        cityStatuses[city].className = 'status-item status-error';
                        cityStatuses[city].textContent = `${city}: 计算失败 - ${error.message}`;
                        return { success: false, city, error };
                    } finally {
                        completed++;
                        updateProgress();
                    }
                }

                // 使用高级队列处理城市
                async function processCitiesWithQueue() {
                    // 创建一个初始并发数与API密钥数量相同的请求队列
                    const requestQueue = new RequestQueue(LOCATIONIQ_KEYS.length, 100);
                    console.log(`开始处理城市，初始并发数：${requestQueue.maxConcurrent} (与API密钥数量相同)，初始延迟：${requestQueue.currentDelay}ms`);
                    
                    // 添加所有城市到请求队列
                    const cityProcessPromises = stateCities.map(city => {
                        return requestQueue.add(() => processCity(city));
                    });
                    
                    // 等待所有城市处理完成
                    await Promise.allSettled(cityProcessPromises);
                    
                    console.log(`所有城市处理完成，最终并发数：${requestQueue.maxConcurrent}，最终延迟：${requestQueue.currentDelay}ms`);
                    console.log(`总计：成功=${requestQueue.totalSuccess}，失败=${requestQueue.totalFailure}`);
                }

                // 开始智能并发处理
                await processCitiesWithQueue();

                if (results.length === 0) {
                    showError('无法计算任何城市的距离');
                    return;
                }

                // 按距离排序（从近到远）
                results.sort((a, b) => a.distance - b.distance);

                // 显示结果
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = `
                    <div style="margin-bottom: 15px; font-weight: bold;">
                        以下城市按距离从近到远排序（单位：英里，驾车时间为估算值）：
                    </div>
                    <div style="margin-bottom: 15px; color: #666;">
                        总共处理: ${total} 个城市, 成功: ${successCount}, 失败: ${errorCount}
                    </div>
                `;
                
                if (results.length === 0) {
                    resultsDiv.innerHTML += '<div class="error">没有成功计算任何城市的距离</div>';
                } else {
                    results.forEach(result => {
                        const estimatedMark = result.estimated ? ' <small style="color: #999;">(估计值)</small>' : '';
                        const cityDiv = document.createElement('div');
                        cityDiv.className = 'city-item';
                        cityDiv.innerHTML = `
                            <span>${result.city}</span>
                            <div>
                                <span><b>${result.distance}</b> 英里 (约 ${result.duration} 分钟${estimatedMark})</span>
                                <a href="https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(address)}&destination=${encodeURIComponent(result.city + ', ' + stateKey)}" 
                                   target="_blank" style="margin-left: 10px;">
                                    <button>导航</button>
                                </a>
                            </div>
                        `;
                        resultsDiv.appendChild(cityDiv);
                    });
                }

            } catch (error) {
                showError(error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // 显示错误信息
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }
    </script>
    
    <!-- 页面底部版权声明 -->
    <footer style="text-align: center; margin-top: 30px; padding: 15px; border-top: 1px solid #ddd; color: #666; font-size: 12px;">
        <p>© 2023-2024 顶流广告技术有限公司 版权所有</p>
        <p>技术支持：Ski定点查询系统</p>
    </footer>
</body>
</html> 