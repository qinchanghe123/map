<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>店铺距离计算器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-group {
            margin-bottom: 20px;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        .results {
            margin-top: 20px;
        }
        .city-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .city-item:last-child {
            border-bottom: none;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .error {
            color: red;
            margin: 10px 0;
        }
        .progress-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-filled {
            height: 20px;
            background-color: #4CAF50;
            text-align: center;
            line-height: 20px;
            color: white;
            transition: width 0.3s;
        }
        .status-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .status-item {
            margin-bottom: 5px;
            font-size: 14px;
        }
        .status-pending {
            color: #888;
        }
        .status-processing {
            color: #ff9800;
        }
        .status-success {
            color: #4CAF50;
        }
        .status-error {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>店铺距离计算器</h1>
        <div class="input-group">
            <input type="text" id="addressInput" placeholder="请输入店铺地址">
            <button onclick="calculateDistances()">计算距离</button>
        </div>
        <div class="note" style="margin-top: 10px; font-size: 14px; color: #666;">
            注意：显示的驾车时间和距离为系统估算值，实际驾驶时间可能因交通状况、天气等因素而有所不同。
            点击"导航"按钮可在谷歌地图中查看更详细的路线信息。
        </div>
        <div id="loading" class="loading">正在计算中...</div>
        <div id="error" class="error"></div>
        <div id="progress-container" class="progress-container" style="display: none;">
            <div class="progress-bar">
                <div id="progress-filled" class="progress-filled" style="width: 0%">0%</div>
            </div>
            <div id="status-list" class="status-list"></div>
        </div>
        <div id="results" class="results"></div>
    </div>

    <script>
        // 警告：这里直接暴露了 API 密钥，在生产环境中应该使用后端服务来保护密钥
        const LOCATIONIQ_KEYS = [
            'pk.7a610aa57d0d98f9e069f4060b882135',
            'pk.8d623bbfe7c58d6fe46c73ff34aad01f',
            'pk.ee34ef023b0a61d9bcb6205c6372e4a7',
            'pk.b0de4a0841c2547ad5724f78f3acdcbc',
            'pk.7d611d26ef05fc49cffe2da526053667',
            'pk.da33d9653e55e08fbcfe2da526053667',
            'pk.9dc953462b77df2460c7f05732706958',
            'pk.45f647b1a1780e83133ecacaaf1cd153',
            'pk.bffb77dd0872aa9d9109a5c15095cef6'
        ];
        
        // 随机打乱API密钥顺序，提高负载均衡效果
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // 初始化时随机打乱密钥顺序
        shuffleArray(LOCATIONIQ_KEYS);
        let currentKeyIndex = 0;

        // 获取下一个API密钥，实现简单的轮询
        function getNextApiKey() {
            const key = LOCATIONIQ_KEYS[currentKeyIndex];
            currentKeyIndex = (currentKeyIndex + 1) % LOCATIONIQ_KEYS.length;
            return key;
        }

        let citiesData = null;
        let dataLoaded = false;
        let isLoading = false;
        const MAX_CONCURRENT_REQUESTS = 3; // 最大并发请求数

        // 州缩写到全名的映射
        const stateAbbreviations = {
            "AL": "alabama",
            "AK": "alaska",
            "AZ": "arizona",
            "AR": "arkansas",
            "CA": "california",
            "CO": "colorado",
            "CT": "connecticut",
            "DE": "delaware",
            "FL": "florida",
            "GA": "georgia",
            "HI": "hawaii",
            "ID": "idaho",
            "IL": "illinois",
            "IN": "indiana",
            "IA": "iowa",
            "KS": "kansas",
            "KY": "kentucky",
            "LA": "louisiana",
            "ME": "maine",
            "MD": "maryland",
            "MA": "massachusetts",
            "MI": "michigan",
            "MN": "minnesota",
            "MS": "mississippi",
            "MO": "missouri",
            "MT": "montana",
            "NE": "nebraska",
            "NV": "nevada",
            "NH": "newhampshire",
            "NJ": "newjersey",
            "NM": "newmexico",
            "NY": "newyork",
            "NC": "northcarolina",
            "ND": "northdakota",
            "OH": "ohio",
            "OK": "oklahoma",
            "OR": "oregon",
            "PA": "pennsylvania",
            "RI": "rhodeisland",
            "SC": "southcarolina",
            "SD": "southdakota",
            "TN": "tennessee",
            "TX": "texas",
            "UT": "utah",
            "VT": "vermont",
            "VA": "virginia",
            "WA": "washington",
            "WV": "westvirginia",
            "WI": "wisconsin",
            "WY": "wyoming",
            "DC": "district of columbia"
        };

        // 立即加载城市数据
        loadCitiesData();

        // 加载城市数据的函数
        async function loadCitiesData() {
            if (isLoading) return; // 避免重复加载
            
            isLoading = true;
            document.getElementById('error').textContent = '正在加载城市数据...';
            
            try {
                console.log('开始加载城市数据...');
                const response = await fetch('skipCities.json');
                if (!response.ok) {
                    throw new Error(`加载城市数据失败: ${response.status} ${response.statusText}`);
                }
                const text = await response.text();
                try {
                    const data = JSON.parse(text);
                    if (!data || typeof data !== 'object') {
                        throw new Error('城市数据格式错误');
                    }
                    citiesData = data;
                    dataLoaded = true;
                    console.log('城市数据加载成功:', Object.keys(citiesData).length, '个州');
                    console.log('加载的州列表:', Object.keys(citiesData));
                    document.getElementById('error').textContent = '';
                } catch (jsonError) {
                    console.error('JSON解析错误:', jsonError);
                    console.log('接收到的内容:', text);
                    throw new Error(`城市数据JSON解析失败: ${jsonError.message}`);
                }
            } catch (error) {
                console.error('加载城市数据错误:', error);
                document.getElementById('error').textContent = `无法加载城市数据: ${error.message}，请刷新页面重试`;
            } finally {
                isLoading = false;
            }
        }

        // 辅助函数：延迟指定时间
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 带重试的API请求，支持多密钥轮询
        async function fetchWithRetry(url, retries = 3, delayMs = 1000) {
            let lastError = null;
            let triedKeys = new Set();
            
            // 获取原始URL不包含API密钥的部分
            const baseUrl = url.replace(/key=[^&]+/, 'key=API_KEY_PLACEHOLDER');
            
            while (triedKeys.size < LOCATIONIQ_KEYS.length) {
                const currentKey = getNextApiKey();
                
                // 如果已经尝试过这个密钥，跳过
                if (triedKeys.has(currentKey)) {
                    continue;
                }
                
                triedKeys.add(currentKey);
                
                // 替换URL中的API密钥
                const requestUrl = baseUrl.replace('API_KEY_PLACEHOLDER', currentKey);
                console.log(`使用API密钥: ${currentKey.substring(0, 5)}...${currentKey.substring(currentKey.length - 4)}`);
                
                for (let i = 0; i < retries; i++) {
                    try {
                        // 如果不是第一次尝试，先等待
                        if (i > 0) {
                            console.log(`尝试重新请求 (${i+1}/${retries}), 等待 ${delayMs}ms...`);
                            await delay(delayMs);
                            // 每次重试增加等待时间
                            delayMs = delayMs * 1.5;
                        }
                        
                        const response = await fetch(requestUrl);
                        if (response.ok) {
                            return response;
                        } else if (response.status === 429) {
                            console.warn(`API密钥 ${currentKey.substring(0, 5)}... 请求速率限制，将尝试其他密钥或重试...`);
                            // 如果是速率限制错误，尝试下一个API密钥
                            break;
                        } else {
                            // 其他错误，获取错误信息
                            const errorText = await response.text();
                            lastError = new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                            // 如果不是速率限制错误，继续重试当前密钥
                            if (i === retries - 1) {
                                // 当前密钥的最后一次尝试失败，尝试下一个密钥
                                break;
                            }
                        }
                    } catch (error) {
                        lastError = error;
                        if (i === retries - 1) {
                            // 当前密钥的最后一次尝试失败，尝试下一个密钥
                            break;
                        }
                    }
                }
            }
            
            // 所有密钥都尝试过了，抛出最后一个错误
            throw lastError || new Error('所有API密钥请求都失败了');
        }

        // 使用 LocationIQ API 获取地理编码
        async function geocodeAddress(address) {
            try {
                // 清理和标准化美国地址格式
                const cleanedAddress = address
                    .replace(/\./g, ',')  // 将点号替换为逗号
                    .replace(/\s+/g, ' ')  // 将多个空格替换为单个空格
                    .replace(/(\d+)([A-Za-z])/g, '$1 $2')  // 在数字和字母之间添加空格
                    .replace(/([A-Za-z])(\d+)/g, '$1 $2')  // 在字母和数字之间添加空格
                    .trim();

                console.log('清理后的地址:', cleanedAddress);

                const url = `https://us1.locationiq.com/v1/search.php?key=API_KEY_PLACEHOLDER&q=${encodeURIComponent(cleanedAddress)}&format=json&countrycodes=us&addressdetails=1`;
                console.log('准备请求地理编码API...');
                
                const response = await fetchWithRetry(url, 3, 1500);
                const data = await response.json();
                console.log('地理编码API响应成功!');
                
                if (!Array.isArray(data) || data.length === 0) {
                    throw new Error('未找到匹配的地址');
                }

                const firstResult = data[0];
                if (!firstResult || !firstResult.lat || !firstResult.lon) {
                    throw new Error('API返回的数据缺少坐标信息');
                }

                // 尝试从 API 返回的地址详情中提取州信息
                let state = null;
                if (firstResult.address) {
                    // 首先检查 state_code（州缩写）
                    if (firstResult.address.state_code) {
                        state = firstResult.address.state_code.toUpperCase();
                        console.log('从API获取到州缩写:', state);
                    } 
                    // 如果没有州缩写，则尝试获取州全名并转换为缩写
                    else if (firstResult.address.state) {
                        const stateName = firstResult.address.state.toLowerCase();
                        console.log('从API获取到州全名:', stateName);
                        
                        // 查找州全名对应的缩写
                        for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
                            if (fullName === stateName) {
                                state = abbr;
                                console.log('通过查找转换州全名到缩写:', state);
                                break;
                            }
                        }
                    }
                }

                // 如果API没有提供州信息，尝试从原始地址中提取
                if (!state) {
                    console.log('API未返回州信息，尝试从地址中提取');
                    // 尝试匹配两个大写字母作为州缩写
                    const stateMatch = cleanedAddress.match(/,\s*([A-Z]{2})(\s*,|\s+\d{5}|\s*$)/);
                    if (stateMatch) {
                        state = stateMatch[1].toUpperCase();
                        console.log('从地址中提取到州缩写:', state);
                    }
                }

                // 验证州缩写是否有效
                if (!state) {
                    throw new Error('无法识别地址中的州信息');
                }
                
                if (!stateAbbreviations[state]) {
                    throw new Error(`无效的州缩写: ${state}`);
                }

                return {
                    lat: firstResult.lat,
                    lon: firstResult.lon,
                    state: state
                };
            } catch (error) {
                console.error('地理编码错误:', error);
                throw new Error(`地理编码请求失败: ${error.message}`);
            }
        }

        // 计算驾车时间
        async function calculateDrivingTime(origin, destination) {
            try {
                // 添加参数尝试提高准确性
                const url = `https://us1.locationiq.com/v1/matrix/driving/${origin.lon},${origin.lat};${destination.lon},${destination.lat}?key=API_KEY_PLACEHOLDER&annotations=distance,duration`;
                console.log('准备请求Matrix API...');
                
                const response = await fetchWithRetry(url, 3, 1500);
                const data = await response.json();
                console.log('Matrix API响应成功!');
                
                if (data && data.durations && data.durations[0] && data.durations[0][1]) {
                    // 驾车时间（分钟）
                    const drivingTime = Math.round(data.durations[0][1] / 60);
                    
                    // 如果API返回了距离信息
                    let distance = null;
                    if (data.distances && data.distances[0] && data.distances[0][1]) {
                        // 距离（米）转换为英里 (1英里 = 1609.34米)
                        distance = (data.distances[0][1] / 1609.34).toFixed(1);
                    } else {
                        // 如果API没有返回距离，使用哈弗辛公式计算直线距离（千米）然后转换为英里
                        // 1千米 = 0.621371英里
                        const kmDistance = calculateHaversineDistance(
                            origin.lat, origin.lon, 
                            destination.lat, destination.lon
                        );
                        distance = (kmDistance * 0.621371).toFixed(1);
                    }
                    
                    return {
                        duration: drivingTime,
                        distance: parseFloat(distance)
                    };
                }
                throw new Error('无法计算驾车时间');
            } catch (error) {
                console.error('距离计算错误:', error);
                throw new Error(`距离计算请求失败: ${error.message}`);
            }
        }

        // 使用哈弗辛公式计算两点之间的直线距离（单位：千米）
        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // 地球半径（千米）
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // 主计算函数
        async function calculateDistances() {
            const address = document.getElementById('addressInput').value.trim();
            if (!address) {
                showError('请输入店铺地址');
                return;
            }

            // 检查城市数据是否已加载
            if (!dataLoaded || !citiesData) {
                // 尝试重新加载数据
                showError('城市数据尚未加载完成，正在尝试重新加载...');
                await loadCitiesData();
                
                // 再次检查数据是否加载成功
                if (!dataLoaded || !citiesData) {
                    showError('无法加载城市数据，请刷新页面重试');
                    return;
                }
            }

            // 显示当前加载的州数据
            console.log('当前加载的城市数据状态: 已加载=', dataLoaded);
            console.log('可用的州:', Object.keys(citiesData));

            document.getElementById('error').textContent = '';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').innerHTML = '';
            
            // 重置并显示进度容器
            const progressContainer = document.getElementById('progress-container');
            const progressFilled = document.getElementById('progress-filled');
            const statusList = document.getElementById('status-list');
            progressContainer.style.display = 'block';
            progressFilled.style.width = '0%';
            progressFilled.textContent = '0%';
            statusList.innerHTML = '';

            try {
                // 获取店铺地址的坐标和州
                console.log('开始处理地址:', address);
                const storeLocation = await geocodeAddress(address);
                console.log('解析到的位置信息:', storeLocation);
                
                // 根据州缩写获取全名
                const stateKey = storeLocation.state;
                const stateFullName = stateAbbreviations[stateKey];
                
                console.log('州缩写:', stateKey);
                console.log('州全名:', stateFullName);
                
                if (!stateFullName) {
                    showError(`未知的州缩写 "${stateKey}"，当前支持的州缩写有: ${Object.keys(stateAbbreviations).join(', ')}`);
                    return;
                }
                
                if (!citiesData[stateFullName]) {
                    showError(`未找到州 "${stateKey}" (${stateFullName}) 的城市数据，请确认所选州的数据是否存在`);
                    console.error(`未找到州 "${stateFullName}" 的数据，可用的州有:`, Object.keys(citiesData));
                    return;
                }
                
                const stateCities = citiesData[stateFullName];
                console.log(`${stateFullName} 州的城市数据:`, stateCities);
                
                if (!Array.isArray(stateCities) || stateCities.length === 0) {
                    showError(`州 "${stateKey}" (${stateFullName}) 没有城市数据`);
                    return;
                }

                console.log(`${stateFullName} 州的城市列表:`, stateCities);

                // 初始化状态列表和结果数组
                const cityStatuses = {};
                const results = [];
                let completed = 0;
                const total = stateCities.length;

                // 为每个城市创建状态项
                stateCities.forEach(city => {
                    const statusItem = document.createElement('div');
                    statusItem.className = 'status-item status-pending';
                    statusItem.id = `status-${city.replace(/\s+/g, '-')}`;
                    statusItem.textContent = `${city}: 等待处理...`;
                    statusList.appendChild(statusItem);
                    cityStatuses[city] = statusItem;
                });

                // 更新进度条
                function updateProgress() {
                    const percent = Math.round((completed / total) * 100);
                    progressFilled.style.width = `${percent}%`;
                    progressFilled.textContent = `${percent}%`;
                }

                // 处理单个城市的函数
                async function processCity(city) {
                    try {
                        // 更新状态为处理中
                        cityStatuses[city].className = 'status-item status-processing';
                        cityStatuses[city].textContent = `${city}: 正在计算距离...`;
                        
                        // 构建完整城市地址，确保包含正确的州名
                        const cityAddress = `${city}, ${stateKey}`;
                        console.log(`处理城市: ${cityAddress}`);
                        
                        // 直接获取城市坐标
                        const cityCoords = await geocodeAddress(cityAddress);
                        const travelInfo = await calculateDrivingTime(storeLocation, cityCoords);
                        
                        results.push({ 
                            city, 
                            duration: travelInfo.duration, 
                            distance: travelInfo.distance 
                        });
                        
                        // 更新状态为成功
                        cityStatuses[city].className = 'status-item status-success';
                        cityStatuses[city].textContent = `${city}: ${travelInfo.duration} 分钟 (${travelInfo.distance} 英里)`;
                    } catch (error) {
                        console.error(`处理城市 ${city} 时出错:`, error);
                        // 更新状态为错误
                        cityStatuses[city].className = 'status-item status-error';
                        cityStatuses[city].textContent = `${city}: 计算失败 - ${error.message}`;
                    } finally {
                        completed++;
                        updateProgress();
                    }
                }

                // 并发处理城市
                async function processCitiesConcurrently() {
                    // 创建城市队列
                    const cityQueue = [...stateCities];
                    const activeTasks = [];
                    
                    // 处理队列中的城市，直到队列为空
                    while (cityQueue.length > 0 || activeTasks.length > 0) {
                        // 填充活动任务队列，直到达到最大并发数或队列为空
                        while (activeTasks.length < MAX_CONCURRENT_REQUESTS && cityQueue.length > 0) {
                            const city = cityQueue.shift();
                            const task = processCity(city).then(() => {
                                // 任务完成后从活动任务队列中删除
                                const index = activeTasks.indexOf(task);
                                if (index !== -1) {
                                    activeTasks.splice(index, 1);
                                }
                            });
                            activeTasks.push(task);
                        }
                        
                        // 等待任何一个任务完成
                        if (activeTasks.length > 0) {
                            await Promise.race(activeTasks);
                        }
                    }
                }

                // 开始并发处理
                await processCitiesConcurrently();

                if (results.length === 0) {
                    showError('无法计算任何城市的距离');
                    return;
                }

                // 按距离排序（从近到远）
                results.sort((a, b) => a.distance - b.distance);

                // 显示结果
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '<div style="margin-bottom: 15px; font-weight: bold;">以下城市按距离从近到远排序（单位：英里，驾车时间为估算值）：</div>';
                results.forEach(result => {
                    const cityDiv = document.createElement('div');
                    cityDiv.className = 'city-item';
                    cityDiv.innerHTML = `
                        <span>${result.city}</span>
                        <div>
                            <span><b>${result.distance}</b> 英里 (约 ${result.duration} 分钟)</span>
                            <a href="https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(address)}&destination=${encodeURIComponent(result.city + ', ' + stateKey)}" 
                               target="_blank" style="margin-left: 10px;">
                                <button>导航</button>
                            </a>
                        </div>
                    `;
                    resultsDiv.appendChild(cityDiv);
                });

            } catch (error) {
                showError(error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // 显示错误信息
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }
    </script>
</body>
</html> 